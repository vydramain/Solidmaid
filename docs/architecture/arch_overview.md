# Архитектура объектов, affordance’ов и ability

Ниже — живое описание того, как устроены наши сцены: кто за что отвечает, как связаны руки персонажа, предметы и контроллер. Документ звучит более человечно, но по сути совпадает с тем, что мы уже реализовали в коде.

---

## 1. Зачем всё это

Мы хотим, чтобы любая новая механика (поднятие, бросок, оружие ближнего боя) появлялась без пачки `if`’ов в контроллере. Контроллер формулирует намерение «правая рука взаимодействует», а дальше работает пара свойств: активная способность персонажа и пассивное свойство предмета. Всё — никаких прямых вызовов `request_throw()` из UI.

---

## 2. Объекты

- лежат в `resources/objects`,
- оформлены как отдельные Godot-сцены,
- сами по себе «ничего не умеют», пока внутрь не встроены overlap-сцены (свойства).

Объект может быть обычным `RigidBody3D`, но его поведение описывают вложенные компоненты.

---

## 3. Свойства как компоненты

Мы используем два типа overlap-сцен:

| Тип         | Что делает                                                      | Примеры                         |
|-------------|-----------------------------------------------------------------|---------------------------------|
| Affordance  | Говорит «со мной можно делать X». Ответ на внешние действия.    | `Carriable`, `Throwable`, `Melee` |
| Ability     | Говорит «я умею выполнять X». Активный инициатор действия.      | `CarrySlots`/`AbilityCarry`, `AbilityThrow`, `AbilityMelee` |

Взаимодействие случается только если у активного участника есть подходящая ability, а у цели — подходящее affordance. То есть ability — это ключ, affordance — замочная скважина.

---

## 4. Как проходит взаимодействие

1. Любая сторона может попросить взаимодействие: «я хочу использовать правую руку».
2. Система фиксирует источник (слот руки или interactor) и объект-цель.
3. Сравниваются способности инициатора и свойства цели.
4. Если пара найдена — вызывается обработчик abilities (`carry`, `throw`, `melee` и т.д.).
5. Если нет — ability возвращает «ничего» и система переходит в idle.

---

## 5. Руки персонажа и контроллер

- Команда «Взаимодействовать правой рукой» проверяет, есть ли в слоте предмет.
  - Если слот занят, проверяем affordance предмета → выбираем подходящее ability → выполняем (бросок, удар, другое).
  - Если слот пуст, interactor ищет ближайший объект и снова сверяет пары.
- В любом случае контроллер не знает конкретный метод (`throw`, `pickup`, `swing`). Он только прокидывает запрос в ability.
- Нет цели? Ability вернёт `do_nothing()` — в игре не произойдёт ничего, но и ошибки не будет.

---

## 6. Примеры (в том виде, как они реализованы)

1. **Подбор кирпича.** Персонаж обладает ability `carry`, кирпич — affordance `carriable`. Слот пуст → ability отправляет предмет в выбранную руку.
2. **Бросок.** В слоте лежит кирпич с affordance `throwable`. Команда на ту же руку запускает ability `throw`, и предмет улетает, освобождая слот.
3. **Pipe как оружие.** У трубы есть affordance `melee`, а у персонажа — ability `melee`. Взаимодействие запускает анимацию взмаха и hurtbox.
4. **Пустая рука.** На цели нет ни одного подходящего свойства — ability возвращает заглушку `do_nothing()`.

---

## 7. Структура каталогов (приблизительно)

```
resources/
  objects/
    brick/Brick.tscn
    pipe/Pipe.tscn
    character/Character.tscn
  overlap/
    abilities/
      Carry.tscn
      Throw.tscn
      Melee.tscn
    affordances/
      Carriable.tscn
      Throwable.tscn
      Melee.tscn
```

Сами названия не важны — принцип один: объект подключает нужные сцены, ability ищет affordance.

---

## 8. Алгоритм взаимодействия

1. Игрок жмёт кнопку. Контроллер знает, какая рука должна среагировать.
2. Берём объект из слота (если есть) или текущую цель interactor’а (если слот пуст).
3. Определяем список affordance’ов.
4. Спрашиваем у способностей персонажа, кто умеет с этим работать.
5. Первый подходящий ability запускает свою логику.
6. Результат действия (успех/нет цели) возвращается контроллеру.

---

## 9. Требования к реализации

- Контроллер не вызывает специфические методы предметов.
- Объекты не знают, как именно их используют — они лишь публикуют affordance.
- Любое новое свойство подключается через добавление новой ability/affordance‑пары, без переписывания входного кода.
- Любой объект, у которого есть нужный набор свойств, автоматически поддерживается системой.

---

## 10. Как расширять систему

1. Создаём `AbilityX` (активное поведение).
2. Создаём `AffordanceX` (пассивная метка).
3. В ability описываем, что делать при совпадении.
4. Подключаем селектор в контроллере (обычно это просто добавление в список способностей).

Никаких тонких интеграций не требуется — пары ключ‑замок работают универсально.

---

## 11. Результат

Такой подход:

- поддерживает слабое связывание и читаемую архитектуру,
- оставляет контроллер “тупым” маршрутизатором намерений,
- позволяет добавлять новые типы взаимодействий без правки старого кода,
- помогает эволюционировать проект к ECS‑подобной модели, но без переусложнения на ранних этапах.

Если нужно объяснить систему новичку — достаточно показать ему эту страницу: выбираешь ability, ищешь affordance, запускаешь действие. Всё.
